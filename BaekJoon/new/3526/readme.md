#문제이해

    n개의 문
    문에서 문으로 복도가 존재.
    복도는 양방향, 자기자신으로 오는 복도도 존재
    최단경로의 길이를 출력하고
    이때 경로를 출력(같은 길이일 경우 이상적인 경로. 사전순으로 앞서는 경우)

    방의 수 n은 최대 10만
    복도의 수 m은 최대 20만


#문제설계 및 풀이

    그래프를 활용하는 문제인 것 같다.
    시작과 끝점이 정해져 있다.
    최단 경로를 찾는 다익스트라 알고리즘을 활용해보자.

    1번에서 n번방까지 가는 경로를 찾아내는데 자기 자신으로 돌아가는 복도를 이용할 이유가 있을까?

    같은 방을 연결하는 복도는 두 개 이상 존재해야할 필요가 없을 듯 하다. 복도가 여러 개라면 한 개의 복도만 살려두면 되지 않을까?

    방을 꼭지점으로 하고 복도를 변으로 하는 그래프를 만들어 보자. (그래프 구현 자료구조)
    
    보통 링크드리스트를 이용해서 구현을 했던 것으로 기억한다. 다익스트라 알고리즘을 구현하기 위해 자주 사용하는 자료구조가 무엇인지 알아볼 필요가 있다.

    또한 다익스트라 알고리즘을 구현하기 위해 우선순위 큐가 필요했다. 힙을 직접 구현해 우선순위 큐를 만들어보자.

    1. 그래프 구현에 필요한 자료구조.
        노드가 10만개라고 가정.
        크기가 10만인 1차원 배열을 사용할 예정.
        배열의 각 원소는 1번(인덱스 1)방에서 부터 각 원소의 인덱스에 해당하는 방에 도달하는데 필요한 시간을 기록.
        해당 노드와 연결된 다른 노드의 정보를 기록(배열로->해시맵으로)

        복도의 개수가 20만개라고 가정(이게 문제)
        복도의 정보가 없다면 ->새로 삽입
        복도의 정보가 이미 있다면 -> 업데이트 필요.
        업데이트를 한다면 어떻게?
        위에 10만개 길이의 배열 원소에 연결노드정보를 순회해서 수정해야함
        최악의 경우 O(m^2)의 시간복잡도가 예상됨. 해시맵을 사용하자


    2. 다익스트라 구현에 필요한 우선순위 큐
    ----
    어리석은 문제 접근 방법이었다..
    그래프 문제지만 모든 edge의 weight가 1이고, 경로의 우선순위는 엣지가 가지는 특성인 엣지(복도)의 색깔이라는 문제였다..
    다익스트라를 이용해 문제를 구현하는 방법은 엣지의 웨이트가 달라 최단 경로를 구하는 문제에서 사용된다. 따라서 다익스트라를 이용하는 접근은 그래프 문제처럼 보였기에 섣부르게 판단한 방법이다.

    문제의 해답은 무엇일까? BFS? 일단 DFS는 아니다. BFS를 하되, 같은 방을 연결하는 복도는 사전순으로 앞서는색깔의 복도만 이용하고,
    모든 경로를 사전순으로 방문해 n번방에 도착하는 순간 경로를 출력하는 방법을 사용하자.

    그러기 위해 맵을 구현해야하고, 큐에는 해당 노드를 접근하기 직전에 접근한 노드를 포함하는 원소를 갖는 노드로 해결하자




#문제점
