#문제이해

    키워드
    2진수 덧셈
    받아올림이 없는 덧셈
    정수 n개가 주어짐
    받아올림 없는 2진수 덧셈을 실행하는 S(i,j)
    임의의 x에 대해 S(i,j)=x인 쌍 (i,j)의 개수
    
    시간제한 1초
    n의 크기 10만
    테스트케이스 10개

#문제설계 및 풀이

    받아올림을 하지 않는 이진수 덧셈을 구현
    받아올림을 하지 않는 이진수 덧셈 연산자를 @ 이라고 하면 각 비트의 연산은
    1 @ 1 = 0
    1 @ 0 = 1
    0 @ 1 = 1
    0 @ 0 = 0
    으로 XOR연산이 된다. 논리회로를 공부해 봤다면 더 쉽게 이핼 수 있다.

    아래는 문제에서 주어진 예시를 XOR연산 하였을 경우 나타나는 결과이다.

    0 0 1 1 (3)
    0 1 1 1 (7)
    -------
    0 1 0 0 (4)

    
    각 원소의 최대값은 20억이지만, 받아올림이 발생하지 않으므로 오버플로우 걱정은 없겠다.

    
    일단 기본적으로 모든 조합에 대해 x와 일치하는지를 판단해야한다.
    그러나 그냥 막 조사하고자 모든 쌍을 계산하면, O(n^2)의 연산으로 너무 많은 조합을 계산해야한다. 게다가 테스트 케이스 개수가 10개이므로 이건 기각.

    결과를 기억해서 쓸 수 있을까?
    예를들어, 3과 7의 연산 결과를 저장하여 다음에 나오는 똑같은 조합에 대해 두 번 연산할 필요 없게 하는 것.
    숫자 범위가 너무 넓다. 기각.

    모두 계산해 두고 x와 일치하는 값을 찾는 것이 기본. 그러나 여기서 후보가 될 수 없는 값들이 있다.

    XOR연산의 특징은 A^B = C, C^A= B라는 특징이 있다. 이를 활용해 볼 수 있을까?
    v[i] ^ v[j] = x 인 경우의 x 값을 찾기보다
    v[i] ^ x = v[j] = A 라 할 때, 이 A값의 개수를 세주면 될 것 같다.


    숫자의 개수를 세는데는 O(n)이 걸리고,
    다시 x과 XOR연산을 통해 답을 찾는 과정에서 O(n)이 소요될 것이다. 전체적으로 시간 복잡도는 O(n)일 것으로 기대한다.

    숫자의 갯수는 해시맵을 이용해 세도록 하자. 숫자의 범위가 너무 크다.



#문제점

    맵을 이용해 v[i]^x = A 의 개수를 받아오려고 했다.
    i < k에 대해 v[k]^x = B 의 개수를 찾으려 할 때,
    v[k] = A 라면, v[i]에서 한 번 뺐다는 것을 반영해야 한다.
    즉 S(i, k) = S(k, i)이므로 빼주어야 한다.
    만약 갯수를 찾은 경우, 맵의 값을 어떻게 변화 시켜야 하는가?

    탐색을 시작하는 시점에서 맵의 v[i]값을 -1 해주면 된다.
    ----
    1차 제출 = 시간 초과.
    맵을 사용했는데도 시간초과가 발생했다.
    unordered_map 을 이용해 시간초과를 면했다.
    
    map과 unodered_map의 차이 :
    https://coding-insider.tistory.com/entry/map-vs-unorderedmap

    2차 제출 = 틀렸습니다.
    왜 틀린거지..? 어째서..
    
    출력되는 답의 범위가 일반 int값 범위를 넘어섰다. 100,000 * 100,000 = 10,000,000,000이다.
    알고리즘의 오류 없이 출력값의 범위를 고려하지 못해 틀렸다.

    3차 제출 = 맞았습니다.
