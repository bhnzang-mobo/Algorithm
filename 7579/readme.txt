스마트폰 시스템 메모리 비활성화
무작위 X

i번째 앱 Ai가 Mi만큼 메모리를 사용한다고 가정.

각각은 재실행을 위한 비용Ci를 갖고있다

이에 대해 메모리 M을 확보하되 Ci합을 최소화 하고자한다.

N개의 데이터, 합, M이상의 메모리 확보, Ci의 합이 최소

두 가지 변수(메모리,코스트) 를 이용해 어떤 선택이
더 경제적인지
같은 코스트 -> 더 많은 메모리
같은 메모리 -> 더 적은 코스트

비슷한 문제를 풀어본 적 있다 - >snapsack.
코스트의 최소값을 묻고 있지만,
배낭문제로 바꾸기 위해 특정 코스트에 대해 최대 메모리를 구하자.
dparr[N-1]배열은 모든 물건에 대해 코스트 1~10001까지
각 코스트에 대해 최대 메모리를 저장한다.
i 코스트의 최대 메모리가 M이상일 경우, 해당 값을 리턴하고 종료.
최소값이기 때문에 뒤 값은 더이상 찾을 필요 없다
---------------
해당 문제는 내가 아는 문제를 다른 형식으로 바꾼 케이스.
문제의 특성은 최소의 코스트(무게)로 최대의 가치를 취하는 것.
정해진 코스트로 최대의 가치를 취하는 배낭문제랑 다른점은
마냥 최대의 가치를 구하는 배낭 문제와는 달리
M이상의 가치를 가지되, 최저의 코스트를 가져가는 문제였다.
---------------
배낭 문제로 치환해 풀고싶다는 생각을 한 것은
두가지 변수(무게, 가치)를 이용해
경제성을 판단(정해진 코스트에 최대의 가치를 담는)문제라는점이
배낭 문제랑 비슷했기 때문이다.
---------------
최소의 코스트라는 조건은 최대의 가치를 각 코스트 별로 계산하면 됬다
문제를 봤을 때 앱의 갯수가 100개, 코스트의 크기가 100이라는 점으로
최대 고려할 코스트는 10000이라는 점을 이용, 빠른 계산으로 끝낼 수 있다는 점을
이용했다. ->메모리에 대해 코스트 최소값을 계산하는 경우는 1천만가지 경우를 생각해야함.
---------------
dparr[2][10001]로 메모리를 줄였는데 계산시간이 0ms로 줄었다...;
N*10001의 계산(최대 10만회)의 계산이 4ms만에 끝났다.

//
	for(i=0; i<N; ++i){
		for(j=10000; j>C[i]; --j){
			if(dp[j-C[i]] && dp[j]<dp[j-C[i]]+A[i]){
				dp[j]=dp[j-C[i]]+A[i];
			}
		}
		if(dp[j]<dp[j-C[i]]+A[i]){
			dp[j]=dp[j-C[i]]+A[i];
		}
	}
//
이렇게 하면 dparr[10001]하나로 계산이가능하다
snapsack에 대한것, 뒤에서 부터 계산하면
앞전 계산이 필요한 경우에도 특별한 메모리를 추가하지 않아도
계산할 수 있다

**뒤에서부터 계산하기